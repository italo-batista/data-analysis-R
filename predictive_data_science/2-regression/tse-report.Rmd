---
title: "Linear Regression"
author: "Italo Batista"
date: "7 de outubro de 2018"
output:
  rmdformats::readthedown:
    highlight: kate
    fig_heigth: 20
  html_notebook:
    toc: yes
    toc_float: yes
  html_document:
    df_print: paged
    toc: yes
    toc_float: yes       
  pdf_document:
    highlight: tango
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Importando dados

```{r message=FALSE, warning=FALSE, error=FALSE}
library(here)
library(dplyr)
library(readr)

here::set_here()

elections_2006_2010 = readr::read_csv(
  here::here("../data/tse/eleicoes_2006_e_2010.csv"),
  local=readr::locale("br"),
  col_types = cols(
    ano = col_integer(),
    sequencial_candidato = col_integer(),
    quantidade_doacoes = col_integer(),
    quantidade_doadores = col_integer(),
    total_receita = col_double(),
    media_receita = col_double(),
    recursos_de_outros_candidatos.comites = col_double(),
    recursos_de_pessoas_fisicas = col_double(),
    recursos_de_pessoas_juridicas = col_double(),
    recursos_proprios = col_double(),
    `recursos_de_partido_politico` = col_double(),
    quantidade_despesas = col_integer(),
    quantidade_fornecedores = col_integer(),
    total_despesa = col_double(),
    media_despesa = col_double(),
    votos = col_integer(),
    .default = col_character())
  )
```

## Conhecendo os dados

```{r message=FALSE, warning=FALSE, error=FALSE}
elections_2006_2010 %>%
  glimpse()
```

Existem 26 variáveis no nosso data frame e o seus significados são:

- “Sequencial_candidato”: (character) id do candidato
- “Nome”:
- “Numero_cadidato”: (character)
- “UF”: (character)
- “Partido”: (character)
- “Setor_economico_receita” : (character) setor econômico que mais doou (em quantidade de vezes) para o candidato;
- “Quantidade_doacoes”: (integer)
- “Quantidade_doadores”: (integer) número de doadores diferentes
- “Total_receita”: (double) soma em R$ das doações
- “Media_receita”: (double) média das doações
- “recursos_de_outros_candidatos/comites”: (double) quantia em R$ das doações provenientes de outros candidatos ou comite partidário
- “Recursos_de_partidos”: (double) quantia em R$ das doações provenientes de outros candidatos ou partidos
- “Recursos_de_pessoas_físicas”: (double) quantia em R$ das doações provenientes de outros CPFs
- “Recursos_de_pessoas_juridicas”: (double) quantia em R$ das doações provenientes de outros CNPJ
- “Recursos_proprios”: (double) quantia em R$ das doações provenientes do próprio candidato
- “Votos”: (integer) variável alvo. Se refere ao número de votos na campanha de 2014
- “Quantidade_despesas”: (integer)
- “Quantidade_fornecedores”: (integer) número de fornecedores/despesas diferentes
- “Total_despesa”: (double) soma em R$ das despesas de campanha
- “Media_despesa”: (double) média das despesas de campanha
- “Setor_economico_despesa”: (character) setor econômico que o candidato mais gastou na campanha (em quantidade de vezes);
- “Cargo”: (character)
- “Idade”: (int)
- “Sexo”: (character)
- “Grau”: (character)
- “Estado_civil”: (character)

Pela descrição, esperamos que algumas variáveis, como `nome` e `sequencial_candidato`, não influenciem na quantidade de votos. A var `cargo` também não influencia, pois todos as obersações tratam de deputados federais. No nosso primeiro modelo, não iremos utilizar tais variáveis, dado que já esperamos nenhum relacionamento entre elas e a variável `voto`.

Vamos plotar a distribuição das variáveis, desconsiderando as variáveis categóricas.

```{r message=FALSE, warning=FALSE, error=FALSE}
library(reshape2)
library(ggplot2)
library(scales)

remove_categorical_vars_converted = function(data) {
  return(
    data %>%
      select(-c(nome, uf, partido, cargo, sexo, grau, estado_civil, ocupacao))
  )
}

reshaped_data = 
  reshape2::melt(
    elections_2006_2010 %>%
      remove_categorical_vars_converted)

ggplot2::ggplot(reshaped_data, aes(x = value)) + 
  facet_wrap(~variable) + 
  geom_histogram() +
  scale_y_continuous(label = scales::unit_format(unit = "k", scale = 1e-3))  +
  scale_x_continuous(label = scales::unit_format(unit = "k", scale = 1e-3), limits = c(-1000, 10000))  +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

No geral a maioria dos valores das variáveis se concentram ao redor de 0. Esse não é o caso de votos. Votos tem um comportamento mais parecido com total_despesa, media_despesa, total_receita e media_receita.

## Pré-processando 

Convertendo vars categóricas em numéricas

```{r message=FALSE, warning=FALSE, error=FALSE}
categorics_to_numerics = function(dataframe) {
  converted_cols = dataframe %>%
    dplyr::mutate(
    uf = as.numeric(as.factor(uf)),
    nome = as.numeric(as.factor(nome)),
    partido = as.numeric(as.factor(partido)),
    grau = as.numeric(as.factor(grau)),
    estado_civil = as.numeric(as.factor(estado_civil)),
    ocupacao = as.numeric(as.factor(ocupacao)),
    cargo = as.numeric(as.factor(cargo)),
    sexo = as.numeric(as.factor(sexo)),
    sequencial_candidato = as.numeric(as.factor(sequencial_candidato)))
  return(converted_cols)
}

elections_2006_2010 = elections_2006_2010 %>% categorics_to_numerics
```

Filtrando para gerar dois datasets, um para cada ano (2006 e 2010).

```{r message=FALSE, warning=FALSE, error=FALSE}
elections_2006 = elections_2006_2010 %>% filter(ano == 2006)
elections_2010 = elections_2006_2010 %>% filter(ano == 2010)
```

## Treino, Validação e Teste

Criando uma função auxiliar para dividir um dataset de entrada em três de saída (treino, validação e teste).

```{r message=FALSE, warning=FALSE, error=FALSE}
# create a train, validation and tests from the original data frame 
create_train_validate_test = function(dataframe) {
  assignment = sample(
    1:3, size = nrow(elections_2010), 
    prob = c(0.6, 0.2, 0.2), replace = TRUE)

  smp_train = dataframe[assignment == 1, ]
  smp_valid = dataframe[assignment == 2, ]
  smp_test = dataframe[assignment == 3, ]
  
  return(list(smp_train, smp_valid, smp_test))
}
```

## 1. Um modelo de regressão múltipla com todas as variáveis é plausível para explicar a variação em y (número de votos)?

De certo modo já respondemos a essa pergunta. Mais acima, avaliamos que as variáveis abaixo não seriam significantes para a predição:

- sequencial_candidato
- nome
- cargo

Ainda pode haver outras variáveis que também não são boas preditoras. Para poder identificá-las, iremos gerar o modelo e posteriomente avaliá-lo.

### Construindo o modelo

#### 1.1 Em 2006

```{r message=FALSE, warning=FALSE, error=FALSE}
## set seed to make partition reproducible
set.seed(123)

splitted = create_train_validate_test(elections_2006)
train_2006 = splitted[[1]]
valid_2006 = splitted[[2]]
test_2006 = splitted[[3]]
```



```{r message=FALSE, warning=FALSE, error=FALSE}
remove_non_related_vars = function(data) {
    return(
    data %>%
      select(-c(ano, nome, sequencial_candidato, cargo))
  )
}
```



```{r message=FALSE, warning=FALSE, error=FALSE}
regression_linear_model_all_vars = function(train_data) {
  filtered_traind_data = train_data %>% remove_non_related_vars
  model_all_vars_2006 = lm(data = filtered_traind_data, votos ~ .)
  return(model_all_vars_2006)
}

model_all_vars_2006 = regression_linear_model_all_vars(train_2006)
```




#### 1.2 Em 2010. 

```{r message=FALSE, warning=FALSE, error=FALSE}
splitted = create_train_validate_test(elections_2010)
train_2010 = splitted[[1]]
valid_2010 = splitted[[2]]
test_2010  = splitted[[3]]

model_all_vars_2010 = regression_linear_model_all_vars(train_2010)
```



## 2. Comparando e avaliando regressões
### Em 2006 

#### Analisando predição

```{r message=FALSE, warning=FALSE, error=FALSE}
  predictions = predict.lm(model_all_vars_2006, valid_2006)
  votos = valid_2006$votos
  
  predictions_plot = extendrange(c(votos, predictions)) +
    plot(votos, predictions, main="Resíduos vs. Predições") +
    abline(0, 1, col="blue", lty=2, lwd=2)
```
R: Quanto melhor o modelo mais próximos da linha azul estão os pontos. Há muitos pontos distantes.

#### Analisan resíduos

```{r message=FALSE, warning=FALSE, error=FALSE}
residuos = valid_2006$votos - predictions

residuos_plot = plot(predictions, residuos, main="Análise de Resíduos") +
  abline(h=0,col="blue",lty=2,lwd=2)
```
R: Quanto melhor o modelo mais próximos da linha azul estão os pontos. Os pontos devem estar dispersos simetricamente em relação à linha azul. You want this to look like a shapeless cloud. If there are outliers it means you've gotten some things very wrong, and if there's a clear pattern it usually means you've picked the wrong type of model

Se têm variância constante;

```{r message=FALSE, warning=FALSE, error=FALSE}
require(ggplot2)

residuos_adj_plot = ggplot(model_all_vars_2006, aes(.fitted, .resid)) +
  geom_point() +
  geom_hline(yintercept=0, col="red", linetype="dashed") + 
  xlab("Valores ajustados") + ylab("Resíduos") + 
  ggtitle("Gráfico de Resíduos vs Ajustamento") + 
  theme_bw()
residuos_adj_plot
```
R: Sem padrão nos resíduos.Com nosso modelo inicial podemos observar que o R² ajustado é 0.4785, ou seja, o modelo explica 47.85% dos dados, assim podemos afirmar que este modelo é razoável para explicar a quantidade de votos de um candidato. Porém, o modelo não satisfaz o pressuposto de normalidade na distribuição dos resíduos.

Se têm distribuição normal:

```{r message=FALSE, warning=FALSE, error=FALSE}
normal_plot = qqnorm(model_all_vars_2006$residuals)
qqline(model_all_vars_2006$residuals, col = 2,lwd=2,lty=2)
```

R: qqplot muito desajustado justado à linha reta. Não está OK. For this plot you want to see the residuals lined up along the a diagonal line that goes from the bottom left to top right. If they're strongly off that line, especially in one corner, it means you have a strong skew in your data. 

Calculando RMSE e R2:

```{r}
library(caret)

postResample(predictions, elections_2006$votos)
```

```{r message=FALSE, warning=FALSE, error=FALSE}
summary(model_all_vars_2006)
```

### Em 2010

```{r}
summary(model_all_vars_2006)
```

```{r}

diagnostic_plots = function(model, valid_set) {
  
  Predictions = predict.lm(model, valid_set)
  Votos = valid_set$votos
  predictions_plot = extendrange(c(Votos, Predictions)) +
    plot(Votos, Predictions, main="Resíduos vs Predição") +
    abline(0, 1, col="blue", lty=2, lwd=2)
  predictions_plot
  
  Residuos = Votos - Predictions
  residuos_plot = plot(Predictions, Residuos) +
    abline(h=0,col="blue",lty=2,lwd=2, main="Análise de Resíduos")
  residuos_plot
  
  residuos_adj_plot = ggplot(model, aes(.fitted, .resid)) +
    geom_point() +
    geom_hline(yintercept=0, col="red", linetype="dashed") + 
    xlab("Valores ajustados") + ylab("Resíduos") + 
    ggtitle("Gráfico de Resíduos vs Ajustamento") + 
    theme_bw()
  plot(residuos_adj_plot)
  
  normal_plot = qqnorm(model$residuals)
  qqline(model$residuals, col = 2,lwd=2,lty=2)
}
```

```{r message=FALSE, warning=FALSE, error=FALSE}
diagnostic_plots(model_all_vars_2010, valid_2006)
```

Calculando RMSE e R2:

```{r}
library(caret)

postResample(predictions, elections_2006$votos)
```
